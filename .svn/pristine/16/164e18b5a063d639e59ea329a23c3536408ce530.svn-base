/**
 * author: Triones
 * date  : 2014-08-21
 * desc  : 套接字封装
 */

#include "socket.h"
#include "eventworkthread.h"
#include "eventreactor.h"

static SockEventFsm __sock_fsm[SOCKSTATE_NUM][SOCKEVENT_NUM];
static bool __fsm_init = false;

static const char *strstate(int sockState)
{
	switch (sockState)
	{
		case CLOSED:
			return "CLOSED";
		case CONNECTING:
			return "CONNECTING";
		case ESTABLISHED:
			return "ESTABLISHED";
		case LISTEN:
			return "LISTEN";
		default:
			return "STATE-INVALID";
	}
}

static const char *strevent(int eventType)
{
	switch (eventType)
	{
		case TOCLOSE:
			return "TOCLOSE";
		case TOREAD:
			return "TOREAD";
		case TOWRITE:
			return "TOWRITE";
		default:
			return "EVENT-INVALID";
	}
}

static void init_fsm()
{
	if (!__fsm_init)
	{
		//接入服务器连接
		__sock_fsm[TCPSVRCONN][TOCLOSE].set(CLOSED, &Socket::to_close);
		__sock_fsm[TCPSVRCONN][TOREAD].set(ESTABLISHED, &Socket::to_read);
		__sock_fsm[TCPSVRCONN][TOWRITE].set(ESTABLISHED, &Socket::to_write);
		//连向服务器连接
		__sock_fsm[TCPCLIENTCONN][TOCLOSE].set(CONNECTING, &Socket::to_close);
		__sock_fsm[TCPCLIENTCONN][TOREAD].set(ESTABLISHED, &Socket::to_read);
		__sock_fsm[TCPCLIENTCONN][TOWRITE].set(ESTABLISHED, &Socket::to_write);
		//tcp listen socket
		__sock_fsm[TCPLISTEN][TOCLOSE].set(CLOSED, &Socket::to_close);
		__sock_fsm[TCPLISTEN][TOREAD].set(LISTEN, &Socket::to_read);
		__sock_fsm[TCPLISTEN][TOWRITE].set(LISTEN, &Socket::to_write);
		//udp socket
		__sock_fsm[UDPSOCK][TOCLOSE].set(CLOSED, &Socket::to_close);
		__sock_fsm[UDPSOCK][TOREAD].set(ESTABLISHED, &Socket::to_read);
		__sock_fsm[UDPSOCK][TOWRITE].set(ESTABLISHED, &Socket::to_write);

		__fsm_init = true;
	}
}

Socket::Socket()
{
	_fd = -1;
	_sock_type = SOCKTYPE_NUM;
	_state = CLOSED;
	memset(&_local_addr, 0, sizeof(struct sockaddr_in));
	memset(_local_host, 0, sizeof(_local_addr));
	_local_port = 0;
	memset(&_peer_addr, 0, sizeof(struct sockaddr_in));
	memset(_peer_host, 0, sizeof(_peer_host));
	_peer_port = 0;

	_last_active_time = time(0);
	_need_reconn = false;
	_reconn_timeval = 30;

	_tprotocol = NULL;
	_epoll_dispatcher = NULL;
	_event_reactor = NULL;

	_next = _pre = NULL;
}

Socket::~Socket()
{
	close_socket();
}

int Socket::run_fsm(int event)
{
	init_fsm();

	int e = event;
	int s = CLOSED;
	EventFun next_handler = NULL;

	while (e != FSM_END)
	{
		s = this->_sock_type;
		next_handler = __sock_fsm[s][e].next_handler;

		if (next_handler == NULL)
		{
			OUT_ERROR(NULL, 0, NULL, "can not find hanlder state %s event %s", strstate(s),
			        strevent(e));
			e = FSM_END;
		}
		else
		{
			e = (this->*(next_handler))();
		}
	}

	return FSM_END;
}

int Socket::event_process(int event)
{
	if (event & EV_READ)
		run_fsm(TOREAD);
	if (event & EV_WRITE)
		run_fsm(TOWRITE);

	return FSM_END;
}

static bool is_ipaddr(const char *host)
{
	char c;
	const char *p = host;
	bool ret = true;

	// 是ip地址格式吗?
	while ((c = (*p++)) != '\0')
	{
		if ((c != '.') && (!((c >= '0') && (c <= '9'))))
		{
			ret = false;
			break;
		}
	}

	return ret;
}

static bool set_addr(const char *host, unsigned short port, struct sockaddr &sock_addr)
{
	memset((void*) &sock_addr, 0, sizeof(sock_addr));
	struct sockaddr_in *addr = (struct sockaddr_in *) &sock_addr;
	addr->sin_family = AF_INET;
	addr->sin_port = htons(port);

	if (host == NULL || host[0] == 0)
	{
		addr->sin_addr.s_addr = htonl(INADDR_ANY );
		return true;
	}

	if (is_ipaddr(host))
	{
		addr->sin_addr.s_addr = inet_addr(host);
		return true;
	}
	else
	{
		// 是域名，解析一下
		struct hostent *myhostent = gethostbyname(host);
		if (myhostent != NULL)
		{
			memcpy(&(addr->sin_addr), *(myhostent->h_addr_list), sizeof(struct in_addr));
			return true;
		}
		return false;
	}
}

bool Socket::set_local_address(const char *host, unsigned short port)
{
	strncpy(_local_host, host, sizeof(_local_host) - 1);
	_local_port = port;
	return set_addr(host, port, _local_addr);
}

//设置本地地址
void Socket::set_local_address(const struct sockaddr *addr)
{
	memcpy(&_local_addr, addr, sizeof(struct sockaddr));
	const struct sockaddr_in* addr_in = (const struct sockaddr_in*) addr;
	char *ip = inet_ntoa(addr_in->sin_addr);
	if (ip != NULL)
	{
		strcpy(_local_host, ip);
	}
	_local_port = ntohs(addr_in->sin_port);
}

//设置对端地址
bool Socket::set_peer_addr(const char *host, unsigned short port)
{
	strncpy(_peer_host, host, sizeof(_peer_host) - 1);
	_peer_port = port;
	return set_addr(host, port, _peer_addr);
}

//设置对端地址
bool Socket::set_peer_addr(const struct sockaddr *addr)
{
	memcpy(&_peer_addr, addr, sizeof(struct sockaddr));
	const struct sockaddr_in* addr_in = (const struct sockaddr_in*) addr;
	char *ip = inet_ntoa(addr_in->sin_addr);
	if (ip != NULL)
	{
		strcpy(_peer_host, ip);
	}
	_peer_port = ntohs(addr_in->sin_port);
	return true;
}

bool Socket::bind(const char *ip, unsigned short port)
{
	if (!set_local_address(ip, port)) return false;

	set_reuse_addr(_fd);

	if (::bind(_fd, (struct sockaddr *) &_local_addr, sizeof(_local_addr)) < 0)
	{
		OUT_ERROR(NULL, 0, NULL, "bind %s %d error : %s", ip, port, strerror(errno));
		return false;
	}

	return true;
}

int Socket::send(const void *data, int len)
{
	int ret = 0;
	if (NULL == data || len <= 0)
	{
		OUT_ERROR(NULL, 0, NULL, "Socket send data error");
		ret = -1;
	}

	return ret;
}

//设置socket传输的通信协议
void Socket::set_trans_protocol(TransProtocol* protocol)
{
	_tprotocol = protocol;
}

void Socket::set_event_reactor(IEventReactor *reactor)
{
	_event_reactor = reactor;
	OUT_INFO(NULL, 0, NULL, "_event_reactor[%d] type[%d]", _event_reactor, _sock_type);
}

void Socket::set_epoll_dispatcher(EpollDispatcher *_dispatcher)
{
	_epoll_dispatcher = _dispatcher;
}

void Socket::re_set()
{
	//此函数不可重置socket的类型，因为在SocketPool 中socket是按照类型保存
	_fd = -1;
	_state = CLOSED;

	_local_port = 0;
	memset(&_local_addr, 0, sizeof(struct sockaddr_in));
	memset(_local_host, 0, sizeof(_local_addr));

	_peer_port = 0;
	memset(&_peer_addr, 0, sizeof(struct sockaddr_in));
	memset(_peer_host, 0, sizeof(_peer_host));


	_last_active_time = time(0);
	_need_reconn = false;
	_reconn_timeval = 30;

	_tprotocol = NULL;
	_epoll_dispatcher = NULL;
	_event_reactor = NULL;

	_send_queue.clear();

	_next = _pre = NULL;
}

bool Socket::operator<(const Socket& sock) const
{
	return _fd < sock._fd;
}
void Socket::close_socket()
{
	return;
}

ASYN_CONN_RET Socket::asyn_connect(const char *peer_ip, unsigned int _peer_port,
        IEventReactor* reactor, TransProtocol* protocol)
{
	if (NULL == peer_ip || 0 == _peer_port || NULL == reactor || NULL == protocol)
	{

	}

	OUT_INFO(NULL, 0, NULL, "Socket::asyn_connect");

	return CONNFAILED;
}

void Socket::recove_socket()
{
	re_set();
	SocketPool::instance().recycle(this);
}

