/**
 * author: Triones
 * date  : 2014-08-21
 * desc  : tcp 套接字封装װ
 */
#include "socketpool.h"
#include "../pack/tprotocol.h"
#include "../pack/pack.h"
#include "tcpsocket.h"

TcpSocket::TcpSocket()
{
	read_buffer.set_max_size(64*1024);
	_fd = socket(AF_INET, SOCK_STREAM, 0); 
}

void TcpSocket::close_socket()
{	
	if (_fd > 0)
	{
		::close(_fd);
		_fd = -1;
	}	
}

int TcpSocket::send(const void *data, int len)
{
    if(_state != ESTABLISHED)
    {
        OUT_ERROR(NULL,0,NULL,"tcpsocket::send socket is not ESTABLISHED");
    	return SOCKET_SENDERR;
    }

    _tprotocol->encode((const char *)data, len, &_send_queue);
	_epoll_dispatcher->event_set(this, true, true);
	return OK;
}

ASYN_CONN_RET TcpSocket::asyn_connect(const char* _peer_ip,unsigned int _peer_port
								,IEventReactor* reactor,TransProtocol* protocol)
{
	ASYN_CONN_RET ret = CONNFAILED;
	bool set_flag = false;
	if(NULL == _peer_ip || NULL == reactor || NULL == protocol||NULL == _epoll_dispatcher)
	{
		OUT_ERROR(NULL,0,NULL,"asyn_connect() param error");
		goto asyn_connect_ERROR;
	}
	_event_reactor = reactor;
	_tprotocol = protocol;

	errno = 0;
	set_flag = set_peer_addr(_peer_ip,_peer_port);
	if(!set_flag)
	{
		goto asyn_connect_ERROR;
	}

	if(-1 == _fd)
	{
		 _fd = socket(AF_INET, SOCK_STREAM, 0);
	}
	set_non_block(_fd);
	_state = CONNECTING;	
	if (::connect(_fd, (struct sockaddr *) &_peer_addr, sizeof(_peer_addr)) < 0)
	{
		if(errno == EINPROGRESS)
		{
			OUT_INFO(NULL,0,NULL,"add recon socket to epoll");
            _epoll_dispatcher->event_add(this, true, true);
			ret = CONNBYEPOLL;
			goto asyn_connect_ERROR;
		}
		else
		{
        	OUT_ERROR(NULL,0,NULL,"connect %s %d fail : %s", _peer_host, _peer_port, strerror(errno));
            close_socket();
			ret = CONNFAILED;
		}
		goto asyn_connect_ERROR;
	}

	_state = ESTABLISHED;
	//新连接加入事件分发模块
	_epoll_dispatcher->event_add(this, true, false);
	OUT_INFO(NULL,0,NULL,"asyn_connect to ip[%s] port[%d] success",_peer_host,_peer_port);
	ret = CONNSUCCESS;

	return ret;
asyn_connect_ERROR:
	return ret;
}

//主动关闭套接字
int TcpSocket::to_close()
{
	//通知外界连接断开
	_event_reactor->on_disconn(this);
	//解除与epoll的绑定
	_epoll_dispatcher->event_del(this);
	//通知连接管理模块 连接断开
    _epoll_dispatcher->select_epoll_thread(this)->on_disconnected(this);
	//关闭套接字
	close_socket();
	if(_sock_type == TCPSVRCONN 
			||(TCPCLIENTCONN == _sock_type&& _need_reconn == false ))
	{
		//回收套接字
		recove_socket();
	}
	else if(TCPCLIENTCONN == _sock_type&& _need_reconn )
	{
		_state = CONNECTING;
	}
    return FSM_END;
}

int TcpSocket::to_read()
{	
    if(_state == CONNECTING)
    {
		//连接失败，只触发读事件。返回错误通知
        return to_conn_resp();
    }
	
    int len = 0;
	if(read_buffer.relative_avail() == 0)
	{
        read_buffer.reset();
	}

    int ret = FSM_END;
	len = ::read(_fd, read_buffer.write_pos(),
			read_buffer.relative_avail());
	if (len > 0)
	{	
		//更新TcpSocket 时间戳
		_last_active_time = time(NULL);

		read_buffer.write_offset_add(len);
		PacketQueue recv_queue;
		int offset = _tprotocol->decode(read_buffer.read_pos(), (int)read_buffer.use(), &recv_queue);
		read_buffer.read_offset_add(offset);
        Packet *pack = NULL;

        while((pack = recv_queue.pop()) != NULL)
        {
			//引用计数+1
//			add_ref();
        	_event_reactor->on_read(this,pack);
			//引用计数-1
//			release();

        	delete pack;
        }
	}
	else if (len < 0 && (errno == EAGAIN || errno == EINTR))
	{
		return FSM_END;
	}
	else
	{
		if(len == 0)
		{
			OUT_ERROR(NULL,0,NULL,"recv = 0, close fd %d, errno : %d ", _fd, errno);
		}
		else
		{
			OUT_ERROR(NULL,0,NULL,"recv = -1, close fd %d, reason : %s ", _fd, strerror(errno));
		}
        return TOCLOSE;
	}

	return ret;
}

int TcpSocket::to_write()
{ 	
    if(_state == CONNECTING)
    {
		//连接成功，缓冲区可写
        return to_conn_resp();
    }

    if(_send_queue.size() == 0)
    {
    	_epoll_dispatcher->event_set(this, true, false);
    	return true;
    }

    int offset = 0;
    int len = 0;
    const char *buffer = NULL;
    int buffer_len = 0;

    Packet *pack = NULL;

    int num = 0;
    while(++num <= ONE_SEND_MAX && (pack = _send_queue.pop()) != NULL)
    {
		//pack 指向的内存空间是在TransProtocol中new,发送完毕后需要释放
        buffer = pack->data();
		buffer_len = pack->size();	

        offset = 0;
		while (offset < buffer_len)
		{
			len = ::write(_fd, buffer + offset, buffer_len - offset);
			if (len > 0)
			{
				_last_active_time = time(NULL); 
				offset += len;
				continue;
			}
			else
			{
                int err = errno;
                if(err == EINTR)
                	continue;
                if(err == EAGAIN)
                {	
					//把整个包重发一遍而不是半个包，半个包会引起包序的混乱len
                    Packet *p = new Packet;
                    p->write_block(buffer + offset, buffer_len - offset);
                    _send_queue.push(p);
                    delete pack;
					pack = NULL;
					return FSM_END;
                }
                else
                {
					OUT_ERROR(NULL,0,NULL,"_fd %d write error : %s toclose", _fd, strerror(errno));
					delete pack;
					pack = NULL;
					return TOCLOSE;
                }
			}
		}	
		//正常情况下发送完毕，释放pack指针
		delete pack;
		pack = NULL;
	}

    //说明没有数据了
    if(num <= ONE_SEND_MAX)
    {
        _epoll_dispatcher->event_set(this, true, false);
    }

    return FSM_END;
}

void TcpSocket::shutdown()
{
	if (_fd != -1)
	{
		::shutdown(_fd, SHUT_WR);
	}
}

bool TcpSocket::check_sockfd()
{
	if (_fd == -1 && (_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
	{
		return false;
	}
	return true;
}

int TcpSocket::to_conn_resp()
{ 
    int err = get_socket_error(_fd);
    if(err == 0)
    {
    	_state = ESTABLISHED;
        _epoll_dispatcher->event_set(this, true, false);	
        _last_active_time =time(NULL);
		//connect 成功加入sockMgr 进行连接管理
        _epoll_dispatcher->select_epoll_thread(this)->on_connected(this);
		//通知外部模块 连接成功,引用计数+1
//		add_ref();
    	_event_reactor->on_conn(this);
		//引用计数-1
//		release();
    }
    else
    {
		//重连失败解除fd与epoll的绑定
		_epoll_dispatcher->event_del(this);
    	OUT_ERROR(NULL,0,NULL,"asyn-connect %s %d fail : %s, fd %d", _peer_host, _peer_port, strerror(err), _fd); 
    }
    return FSM_END;
}
