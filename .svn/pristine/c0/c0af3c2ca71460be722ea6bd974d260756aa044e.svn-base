/**
 * author: Triones
 * date  : 2014-08-21
 * desc  : General definition
 */

#include "tcptransport.h"
#include "socketpool.h"

TcpTransPort::TcpTransPort()
{
	_event_reactor = NULL;
	_sock_protocol = NULL;
	_svr_startup = false;
	_cl_startup = false;
}

TcpTransPort::~TcpTransPort()
{
	stop();

	if (NULL != _event_reactor)
	{
		delete _event_reactor;
		_event_reactor = NULL;
	}

	if (NULL != _sock_protocol)
	{
		delete _sock_protocol;
		_sock_protocol = NULL;
	}
}

bool TcpTransPort::start(IEventReactor *reactor, TransProtocol* protocol)
{
	bool ret = false;
	if (NULL == reactor || NULL == protocol)
	{
		return ret;
	}
	_event_reactor = reactor;
	_sock_protocol = protocol;
	ret = true;
	return ret;
}

bool TcpTransPort::stop()
{
	_svr_startup = _cl_startup = false;
	_epoll_dispatcher.stop();
	SocketPool::instance().destroy();
	return true;
}

bool TcpTransPort::tcp_svr_listen(const char *ip, unsigned short port, int thread_num)
{
	bool ret = false;
	TcpListenSocket* _listen_sock = NULL;
	if (NULL == ip || NULL == _event_reactor || NULL == _sock_protocol)
	{
		OUT_ERROR(NULL, 0, NULL, " TCP server param error, ip[%s] port[%d]", ip, port);
		goto tcp_svr_listen_ERROR;
	}
	//至少需要两个线程，其中一个accept(),另一个事件分发
	if (thread_num < 2)
	{
		thread_num = 2;
	}

	_listen_sock = (TcpListenSocket*) SocketPool::instance().get(TCPLISTEN);
	if (!_listen_sock->listen(ip, port, 128))
	{
		_listen_sock->re_set();
		SocketPool::instance().recycle(_listen_sock);
		OUT_ERROR(NULL, 0, NULL, " TCP server start failure: ip[%s] port[%d]", ip, port);
		goto tcp_svr_listen_ERROR;
	}

	//管理多个listen_sock
	if (!_svr_startup)
	{
		//开启事件分发线程池
		_epoll_dispatcher.init(thread_num);
		_epoll_dispatcher.start();
		_svr_startup = true;
		OUT_INFO(NULL, 0, NULL, "dispatcher start success");
	}

	//设置socket属性
	_listen_sock->_state = LISTEN;
	_listen_sock->_sock_type = TCPLISTEN;
	//设置协议解析器和事件反应器
	_listen_sock->set_event_reactor(_event_reactor);
	_listen_sock->set_trans_protocol(_sock_protocol);
	//设置与套接字关联的dispatcher
	_listen_sock->set_epoll_dispatcher(&_epoll_dispatcher);
	//将监听套接字加入事件分发模块
	_epoll_dispatcher.event_add(_listen_sock, true, true);
	ret = true;
	OUT_INFO(NULL, 0, NULL, " TCP server start: ip[%s] port[%d] thread_num[%d]", ip, port,
	        thread_num);

	return ret;
	tcp_svr_listen_ERROR: return ret;
}

TcpSocket* TcpTransPort::tcp_connect(char*peer_ip, int peer_port, int thread_num)
{
	ASYN_CONN_RET ret = CONNFAILED;
	TcpSocket* tcp_sock = NULL;
	if (NULL == peer_ip || NULL == _event_reactor || NULL == _sock_protocol)
	{
		OUT_ERROR(NULL, 0, NULL, " TCP client param error, ip[%s] port[%d]", peer_ip, peer_port);
		goto tcp_connect_ERROR;
	}

	if (!_cl_startup)
	{
		_epoll_dispatcher.init(thread_num);
		_epoll_dispatcher.start();
		_cl_startup = true;
	}
	tcp_sock = (TcpSocket*) SocketPool::instance().get(TCPSVRCONN);
	//在内网环境下 异步连接可能会立马成功
	//设置解包器和反应器
	tcp_sock->set_event_reactor(_event_reactor);
	tcp_sock->set_trans_protocol(_sock_protocol);
	//设置与socket关联的dispatcher
	tcp_sock->set_epoll_dispatcher(&_epoll_dispatcher);
	//设置socket 属性
	tcp_sock->_state = CONNECTING;
	tcp_sock->_sock_type = TCPCLIENTCONN;
	tcp_sock->_need_reconn = true;
	tcp_sock->_next_reconn_time = time(NULL);
	tcp_sock->_reconn_timeval = 30;

	ret = tcp_sock->asyn_connect(peer_ip, peer_port, _event_reactor, _sock_protocol);
	if (CONNFAILED == ret)
	{
		OUT_ERROR(NULL, 0, NULL, " TCP client param error, ip[%s] port[%d]", peer_ip, peer_port);
		goto tcp_connect_ERROR;
	}
	else if (CONNSUCCESS == ret)
	{
		//connect 成功加入sockMgr 进行连接管理
		_epoll_dispatcher.select_epoll_thread(tcp_sock)->on_connected(tcp_sock);
		printf("asyn_connect to ip[%s] port[%d] success \n", peer_ip, peer_port);

		OUT_INFO(NULL, 0, NULL, "asyn_connect to ip[%s] port[%d] success", peer_ip, peer_port);
		//通知外部模块 连接成功
		_event_reactor->on_conn(tcp_sock);
	}

	return tcp_sock;

	tcp_connect_ERROR:
		return tcp_sock;
}

int TcpTransPort::send_msg(Socket* _sock, const char* data_buf, int len)
{
	int ret = -1;
	if (NULL == data_buf || len <= 0 || NULL == _sock || ESTABLISHED != _sock->_state)
	{
		OUT_ERROR(NULL, 0, NULL, "send_msg error socket state[%d]", _sock->_state);
		goto send_msg_ERROR;
	}

	if (_sock->_state == ESTABLISHED)
	{
		((TcpSocket*) _sock)->send(data_buf, len);
	}

	return ret;
	send_msg_ERROR:
		return ret;
}

