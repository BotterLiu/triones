/**
 * author: Triones
 * date  : 2014-08-21
 * desc  : 套接字封装
 */

#ifndef _TRIONES_SOCK_H_
#define _TRIONES_SOCK_H_

#include <map>
#include <set>
using namespace std;
#include "../pack/tprotocol.h"
#include "../utils/tqueue.h"
#include "../log/comlog.h"
#include "../thread/atomic.h"

#include "sockutil.h"
#include "common.h"
#include "sock_buffer.h"

namespace triones
{
class EventWorkThread;
class EpollDispatcher;
class IEventReactor;

class Socket
{
public:
	Socket();

	Socket(int sock, int state, struct sockaddr_in addr);

	virtual ~Socket();

	bool bind(const char *ip, unsigned short port);	

	//异步连接接口
	virtual ASYN_CONN_RET asyn_connect(const char *peer_ip,
			unsigned int peer_port,
			IEventReactor* reactor,
			TransProtocol* protocol);
		

	virtual int send(const void *data, int len);

	virtual void close_socket();

	virtual void recove_socket();

	//状态机处理函数, 由具体的socket实现
	virtual int to_close() {return FSM_END;}

	virtual int to_read() {return FSM_END;}

	virtual int to_write() {return FSM_END;}

	virtual int event_process(int event);

public:   //公用方法类
	//设置socket传输的通信协议
	void set_trans_protocol(TransProtocol* protocol);
	//设置socket 对应的事件分发器
	void set_epoll_dispatcher(EpollDispatcher *_dispatcher);
	 //设置这个socket的业务处理函数
	 void set_event_reactor(IEventReactor *reactor); 

    //设置地址，本地地址。
	bool set_local_address(const char *host, unsigned short port);
	//设置本地地址
	void set_local_address(const struct sockaddr *addr);
	//设置对端地址
	bool set_peer_addr(const char *host, unsigned short port);
	//设置对端地址
    bool set_peer_addr(const struct sockaddr *addr);  
    //状态机循环函数
	int run_fsm(int event);
	//重置socket状态
	void re_set();
	//重载<运算符,使用set保存Socket时用到
	bool operator<(const Socket& sock) const;

public:
	//socket文件描述符
	int _fd;
	//socket状态
	SOCKSTATE _state;
	//socket类型
	int _sock_type;
	//socket本端地址
	struct sockaddr _local_addr;
	char _local_host[MAX_IP_LEN];
	unsigned short _local_port;

	//socket对端地址
	struct sockaddr _peer_addr;
	char _peer_host[MAX_IP_LEN];
	unsigned short _peer_port;

	//上次活动的时间
	time_t _last_active_time;
	//重连标志位,true时为client socket 需要重连 ,false 不需要重连
	bool _need_reconn;
	//重连时间间隔
	int _reconn_timeval;
	//下一次重连的时间
	int _next_reconn_time;
	//分包协议
	TransProtocol *_tprotocol;
	//属于哪一个事件管理器管理
	IEventReactor* _event_reactor;
	//业务回调器
	EpollDispatcher* _epoll_dispatcher;
	//发送队列
	PacketQueue _send_queue;

	//引用计数
	Atomic  _refcnt;

	//链表管理
	Socket* _next;
	Socket* _pre;
};

typedef int (Socket::*EventFun)();

struct SockEventFsm
{
    SOCKSTATE next_state;
    EventFun  next_handler;

    void set(SOCKSTATE n, EventFun h)
    {
        next_state = n;
        next_handler = h;
    }
};
}

#endif /* _TRIONES_SOCK_H_ */
