/**
 * author: Triones
 * date  : 2014-08-27
 * desc  : udp 传输封装
 */

#include "udptransport.h"
UdpTransPort::UdpTransPort()
{
	_event_reactor = NULL;
	_sock_protocol = NULL;
	_thread_num = 1;
	_svr_startup = false;
	_cl_startup = false;
}

UdpTransPort:: ~UdpTransPort()
{	
}

bool UdpTransPort::start(IEventReactor *reactor,TransProtocol* protocol)
{
	bool ret = false;
	if(NULL == reactor || NULL == protocol)
	{
		return ret;
	}
	_event_reactor = reactor;
	_sock_protocol = protocol;
	ret = true;
	return ret;
}

bool UdpTransPort::stop()
{
	_svr_startup = _cl_startup =false;	
    _epoll_dispatcher.stop(); 
    SocketPool::instance().destroy();
	return false;
}

bool UdpTransPort::udp_svr_startup(const char *ip, unsigned short port, int thread_num)
{
	bool ret = false;
	UdpSocket*  _udp_sock = NULL;
	if(NULL == ip|| NULL == _event_reactor||NULL == _sock_protocol)
    {
		OUT_ERROR(NULL,0,NULL," udp server param error, ip[%s] port[%d]", ip, port);
        goto tcp_svr_listen_ERROR;
    }

	//管理多个listen_sock 
	if(!_svr_startup)
	{
		//开启事件分发线程池
		_epoll_dispatcher.init(_thread_num);
		_epoll_dispatcher.start();
		_svr_startup = true;
	}

	_udp_sock = (UdpSocket* )SocketPool::instance().get(UDPSOCK);
	ret = _udp_sock->start_server(ip,port);
	if(!ret)
	{
		OUT_ERROR(NULL,0,NULL," udp server start error, ip[%s] port[%d]", ip, port);
		goto tcp_svr_listen_ERROR;
	}
	//设置协议解析器和事件反应器
    _udp_sock->set_event_reactor(_event_reactor);
	_udp_sock->set_trans_protocol(_sock_protocol); 
	//设置与socket关联的dispatcher
	_udp_sock->set_epoll_dispatcher(&_epoll_dispatcher);
	//设置socket属性
	_udp_sock->_sock_type = UDPSOCK;
	_udp_sock->_state = ESTABLISHED;
	//将监听套接字加入事件分发模块
	_epoll_dispatcher.event_add(_udp_sock,true,false);
    ret = true;
    OUT_INFO(NULL,0,NULL," udp server start: ip[%s] port[%d] thread_num[%d]", ip, port,thread_num);

    return ret;
tcp_svr_listen_ERROR:
	return ret;		
}

UdpSocket* UdpTransPort::udp_cl_connect(char*peer_ip,int peer_port,int local_port,int thread_num )
{
	ASYN_CONN_RET ret = CONNFAILED;
	UdpSocket* udp_sock = NULL;
	if(NULL == peer_ip|| NULL == _event_reactor||NULL == _sock_protocol)
	{
		OUT_ERROR(NULL,0,NULL," TCP client param error, ip[%s] port[%d]", peer_ip, peer_port);
		goto udp_connect_ERROR;
	}

	if(!_cl_startup)
	{
		_epoll_dispatcher.init(thread_num);
		_epoll_dispatcher.start();
		_cl_startup = true;
	}

	udp_sock = (UdpSocket* )SocketPool::instance().get(UDPSOCK);	
	//设置套接字关联的dispatcher
	udp_sock->set_epoll_dispatcher(&_epoll_dispatcher);
	//设置套接字属性
	udp_sock->_sock_type= UDPSOCK;
	udp_sock->_state = CONNECTING;
	udp_sock->_need_reconn = true;
	udp_sock->_next_reconn_time = time(NULL);
	udp_sock->_reconn_timeval = 30;

	ret = udp_sock->asyn_connect(peer_ip,peer_port,_event_reactor,_sock_protocol);
	if(ret == CONNFAILED)
	{
		OUT_ERROR(NULL,0,NULL," udp client bind error,local_port[%d] peer_ip[%s] peer_port[%d]"
					,local_port,peer_ip, peer_port);
		goto udp_connect_ERROR;
	}
	else if(CONNSUCCESS == ret)
	{
		//connect 成功加入sockMgr 进行连接管理
		_epoll_dispatcher.select_epoll_thread(udp_sock)->on_connected(udp_sock);
		_event_reactor->on_conn(udp_sock);

	}

	return udp_sock;
udp_connect_ERROR:
	return udp_sock;
}

int UdpTransPort::send_msg(Socket* sock,const char* data_buf,int len)
{
	int ret = -1;
	if(NULL == data_buf || len<=0|| NULL == sock || ESTABLISHED != sock->_state)
	{
		OUT_ERROR(NULL,0,NULL,"send_msg error socket state[%d]",sock->_state);
		goto send_msg_ERROR;
	}

	ret = ((UdpSocket* )sock)->send(data_buf,len);
	return ret;
send_msg_ERROR:
	return ret;
}



