/**
 * author: Triones
 * date  : 2014-08-21
 * desc  : UDP 套接字封装
 */

#include "udpsocket.h"
#include "eventreactor.h"
#include "epolldispatcher.h"
#include "../log/comlog.h"

static unsigned short get_port(struct sockaddr_in *sockaddr)
{
	return htons(sockaddr->sin_port);
}

static string get_ip(struct sockaddr_in *sockaddr)
{
	return inet_ntoa(sockaddr->sin_addr);
}

UdpSocket::UdpSocket()
{
	memset(&peer_addr, 0, sizeof(peer_addr));
	read_buffer.set_max_size(4 * 1024);
	udp_type = UDP_TYPE_SERVER;
}

UdpSocket::UdpSocket(int sock, SOCKSTATE s, struct sockaddr_in *address)
{
	_fd = sock;
	_state = s;
	memset((void*) &peer_addr, 0, sizeof(peer_addr));
	memcpy(&peer_addr, address, sizeof(struct sockaddr_in));
	read_buffer.set_max_size(4 * 1024);
}

int UdpSocket::get_one_packet(FifoBuffer::FifoPacket *packet)
{
	return read_buffer.get_one_packet(packet);
}

void UdpSocket::close_socket()
{
	if (udp_type == UDP_TYPE_CONN)
	{
		//通知外界udp客户端连接断开
		_event_reactor->on_disconn(this);
		_epoll_dispatcher->event_del(this);

		_epoll_dispatcher->select_epoll_thread(this)->on_disconnected(this);

		//断开有连接的udp-socket
		struct sockaddr_in server_addr;
		memset(&server_addr, 0, sizeof(server_addr));
		server_addr.sin_family = AF_UNSPEC;
		server_addr.sin_port = htons(_peer_port);
		server_addr.sin_addr.s_addr = inet_addr(_peer_host);
		::connect(_fd, (struct sockaddr*) &server_addr, sizeof(struct sockaddr));

		if (_fd > 0)
		{
			::close(_fd);
			_fd = -1;
		}

		if (_need_reconn)
		{
			_state = CONNECTING;
		} else
		{
			//重置、回收套接字
			re_set();
			SocketPool::instance().recycle(this);
		}
	}
}

int UdpSocket::send(const void *data, int len)
{
	int send_len = 0;
	if (NULL == data || len <= 0 || _state != ESTABLISHED)
	{
		OUT_ERROR(NULL, 0, NULL, "send error,_state[%d]", _state);
		return send_len;
	}

	_tprotocol->encode((const char*) data, len, &_send_queue);

	if (udp_type == UDP_TYPE_VIRTUAL)
	{
		//udp 接入端
		Packet *pack = _send_queue.pop();
		int left_len = pack->size();
		const char* left_ptr = (const char*) pack->data();
		int send_times = 0;

		while (left_len > 0)
		{
			int ret = ::sendto(_fd, left_ptr, left_len, 0, (struct sockaddr *) &_peer_addr,
			        sizeof(struct sockaddr));
			if (ret == -1)
			{ //出错了
				if (++send_times > 2)
				{ // 记录发送出错的次数
					send_len = SOCKET_SENDERR;
					break;
				}
				continue;
			}

			left_len -= ret;
			left_ptr += ret;
			send_len += ret;
		}
	} else
	{	//udp 客户端
		_epoll_dispatcher->event_set(this, true, true);
	}

	return send_len;
}

//状态机处理函数
int UdpSocket::to_close()
{
	close_socket();
	return FSM_END;
}

static long long __recv_sum = 0;

int UdpSocket::to_conn_resp()
{
	int err = get_socket_error(_fd);
	if (err == 0)
	{
		_state = ESTABLISHED;
		_epoll_dispatcher->event_set(this, true, false);
		_last_active_time = time(NULL);
		//connect 成功加入sockMgr 进行连接管理
		_epoll_dispatcher->select_epoll_thread(this)->on_connected(this);
		//通知外部模块 连接成功,引用计数+1
//		add_ref();
		_event_reactor->on_conn(this);
//		release();	//引用计数-1
	} else
	{
		_epoll_dispatcher->event_del(this);
		OUT_ERROR(NULL, 0, NULL, "asyn-connect %s %d fail : %s, fd %d", _peer_host, _peer_port,
		        strerror(err), _fd);
	}
	return FSM_END;
}

void UdpSocket::discon_virturl_sock(const struct sockaddr *addr)
{
	UdpSocket* _udp_sock = NULL;
	long long index = get_index((const struct sockaddr_in *) &addr);
	//通知外界虚拟接入端连接断开
	_event_reactor->on_disconn(this);
	virtual_udpsock.erase(index);
	if (NULL != _udp_sock)
	{
		delete _udp_sock;
		_udp_sock = NULL;
	}
}

int UdpSocket::to_read()
{
	if (_state == CONNECTING)
	{
		//只响应udp客户端
		to_conn_resp();
	}

	int ret = FSM_END;
	size_t decode_len = 0;
	char *buffer = new char[WR_SOCK_LEN];
	struct sockaddr recvaddr;
	int addr_len = sizeof(recvaddr);

	memset(&recvaddr, 0, sizeof(recvaddr));
	int recv_bytes = ::recvfrom(_fd, buffer, WR_SOCK_LEN, 0, (struct sockaddr *) &(recvaddr),
	        (socklen_t*) (&addr_len));

	if (recv_bytes <= 0)
	{
		OUT_ERROR(NULL, 0, NULL, "recvfrom  %s %d  ret %d error(%s)",
		        get_ip((struct sockaddr_in* ) &recvaddr).c_str(),
		        get_port((struct sockaddr_in* ) &recvaddr), recv_bytes, strerror(errno));
		if (errno != EAGAIN)
		{
			if (udp_type == UDP_TYPE_VIRTUAL)
			{
				discon_virturl_sock(&recvaddr);
			}
			ret = TOCLOSE;
		}

		delete[] buffer;
		return ret;
	}

	OUT_INFO(NULL, 0, NULL, "fd[%d]recv [%s] len[%d]", _fd, buffer, recv_bytes);

	__recv_sum += recv_bytes;

	if (udp_type == UDP_TYPE_CONN)
	{
		_last_active_time = time(NULL);
		Packet* pack = _tprotocol->decode_pack(buffer, (size_t) recv_bytes, decode_len);
		if (pack != NULL && decode_len > 0)
		{
			//引用计数+1
//			add_ref();
			_event_reactor->on_read(this, pack);
			//引用计数-1
//			release();
		} else
		{
			OUT_ERROR(NULL, 0, NULL, "fd[%d] decode pack error,decode_len[%d]", _fd, decode_len);
		}
	} else // UDP_TYPE_SERVER, 找到对应的客户端Socket;
	{
		long long index = get_index((const struct sockaddr_in *) &recvaddr);

		if (virtual_udpsock.find(index) == virtual_udpsock.end())
		{
			UdpSocket *udp_socket = new UdpSocket(_fd, ESTABLISHED,
			        (struct sockaddr_in*) &recvaddr);
			//设置套接字属性
			udp_socket->_fd = _fd;
			udp_socket->set_peer_addr(&recvaddr);
			udp_socket->udp_type = UDP_TYPE_VIRTUAL;
			//设置解包器和反应器
			udp_socket->set_event_reactor(_event_reactor);
			udp_socket->set_trans_protocol(_tprotocol);
			virtual_udpsock.insert(make_pair(index, udp_socket));
		}
		_last_active_time = time(NULL);
		UdpSocket *socket = virtual_udpsock[index];
		Packet* pack = _tprotocol->decode_pack(buffer, recv_bytes, decode_len);
		_event_reactor->on_read(socket, pack);
	}

	delete[] buffer;

	return ret;
}

int UdpSocket::to_write()
{
	const char* buffer = NULL;
	int buffer_len = 0;
	int send_count = 0;
	Packet *pack = NULL;
	int send_ret = FSM_END;
	int offset = 0;

	if (_fd < 0 || _state != ESTABLISHED)
	{
		OUT_ERROR(NULL, 0, NULL, "to_write fail, _fd : %d , _state : %d", _fd, _state);
		goto to_write_ERROR;
	}

	while (++send_count <= ONE_SEND_MAX && (pack = _send_queue.pop()) != NULL)
	{
		buffer = pack->data();
		buffer_len = pack->size();

		while (offset < buffer_len)
		{
			int send_bytes = ::sendto(_fd, buffer + offset, min(WR_SOCK_LEN, buffer_len - offset),
			        0, (struct sockaddr *) &_peer_addr, sizeof(struct sockaddr));
			if (send_bytes <= 0)
			{
				OUT_ERROR(NULL, 0, NULL, "sendto %s %d ret %d error(%s) errno[%d]",
				        get_ip((struct sockaddr_in * )&_peer_addr).c_str(),
				        get_port((struct sockaddr_in * )&_peer_addr), send_bytes, strerror(errno),
				        errno);

				if (errno == EAGAIN)
				{
					_send_queue.push(pack);
					goto to_write_ERROR;
				}
				//删除断开的虚拟接入端
				if (udp_type == UDP_TYPE_VIRTUAL)
				{
					discon_virturl_sock(&_peer_addr);
				}
				send_ret = TOCLOSE;
				goto to_write_ERROR;
			}

			offset += send_bytes;
		}
	}

	if (send_count <= ONE_SEND_MAX)
	{
		_epoll_dispatcher->event_set(this, true, false);
	}

	return send_ret;
	to_write_ERROR: return send_ret;
}

bool UdpSocket::start_server(const char *ip, unsigned short port)
{
	bool ret = false;
	if (!check_sockfd()) return ret;

	//套接字属性设置
	set_non_block(_fd);
	set_reuse_addr(_fd);

	if (this->bind(ip, port))
	{
		udp_type = UDP_TYPE_SERVER;
		_state = ESTABLISHED;
		ret = true;
	}

	return ret;
}

ASYN_CONN_RET UdpSocket::asyn_connect(const char *peer_ip, unsigned int peer_port,
        IEventReactor* reactor, TransProtocol* protocol)
{
	ASYN_CONN_RET ret = CONNFAILED;
	int con_flag = 0;
	struct sockaddr_in server_addr;

	if (NULL == peer_ip || NULL == _epoll_dispatcher)
	{
		OUT_ERROR(NULL, 0, NULL, "udp asyn_connect param error");
		goto asyn_connect_ERROR;
	}
	_event_reactor = reactor;
	_tprotocol = protocol;

	if (!check_sockfd())
	{
		goto asyn_connect_ERROR;
	}

	// 获取当前socket的属性， 并设置 noblocking 属性
	memset(&server_addr, 0, sizeof(server_addr));
	server_addr.sin_family = PF_INET;
	server_addr.sin_port = htons(peer_port);
	server_addr.sin_addr.s_addr = inet_addr(peer_ip);
	//套接字属性设置
	set_non_block(_fd);
	udp_type = UDP_TYPE_CONN;
	//设置对端地址信息
	strncpy(_peer_host, peer_ip, sizeof(_peer_host));
	_peer_port = peer_port;
	set_peer_addr(_peer_host, _peer_port);

	_state = CONNECTING;
	con_flag = ::connect(_fd, (struct sockaddr*) &server_addr, sizeof(struct sockaddr));
	if (con_flag != 0)
	{
		if (errno == EINPROGRESS)
		{
			_epoll_dispatcher->event_add(this, true, true);
			ret = CONNBYEPOLL;
			goto asyn_connect_ERROR;
		}
		ret = CONNFAILED;
		OUT_ERROR(NULL, 0, NULL, "UDP connect %s %d fail : %s", _peer_host, _peer_port,
		        strerror(errno));
		goto asyn_connect_ERROR;
	}

	_state = ESTABLISHED;
	//新连接加入事件分发模块
	_epoll_dispatcher->event_add(this, true, false);
	ret = CONNSUCCESS;

	return ret;
	asyn_connect_ERROR: return ret;
}

void UdpSocket::shutdown()
{
	if (_fd != -1)
	{
		::shutdown(_fd, SHUT_WR);
	}
}

bool UdpSocket::set_recv_buffer_size(int s)
{
	read_buffer.set_max_size(s);
	return true;
}

bool UdpSocket::check_sockfd()
{
	if (_fd == -1 && (_fd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
	{
		return false;
	}

	int optval = 1024 * 1024;
	int optlen = sizeof(optval);

	set_non_block(true);
	setsockopt(_fd, SOL_SOCKET, SO_RCVBUF, (char*) &optval, optlen);
	setsockopt(_fd, SOL_SOCKET, SO_SNDBUF, (char*) &optval, optlen);

	return true;
}

long long UdpSocket::get_index(const struct sockaddr_in *addr)
{
	long long index = 0;
	index = (uint32_t) (addr->sin_addr.s_addr);
	index = (index << 4) | addr->sin_port;

	return index;
}

long long UdpSocket::get_index(const char *ip, unsigned short port)
{
	long long index = inet_addr(ip);
	index = (index << 4) | htons(port);
	return index;
}

